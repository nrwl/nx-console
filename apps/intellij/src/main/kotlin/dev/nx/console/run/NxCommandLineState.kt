package dev.nx.console.run

import com.intellij.execution.DefaultExecutionResult
import com.intellij.execution.ExecutionResult
import com.intellij.execution.process.ProcessHandler
import com.intellij.execution.process.ProcessTerminatedListener
import com.intellij.execution.runners.ExecutionEnvironment
import com.intellij.execution.target.value.TargetValue
import com.intellij.execution.wsl.WslPath
import com.intellij.ide.util.PropertiesComponent
import com.intellij.javascript.debugger.CommandLineDebugConfigurator
import com.intellij.javascript.nodejs.NodeCommandLineUtil
import com.intellij.javascript.nodejs.NodeCommandLineUtil.createConsole
import com.intellij.javascript.nodejs.debug.NodeCommandLineOwner
import com.intellij.javascript.nodejs.execution.NodeBaseRunProfileState
import com.intellij.javascript.nodejs.execution.NodeTargetRun
import com.intellij.javascript.nodejs.execution.NodeTargetRunOptions
import com.intellij.javascript.nodejs.npm.*
import com.intellij.notification.NotificationAction
import com.intellij.openapi.diagnostic.thisLogger
import com.intellij.openapi.project.Project
import com.intellij.openapi.ui.MessageType
import com.intellij.openapi.wm.ToolWindowManager
import com.intellij.util.execution.ParametersListUtil
import com.intellij.xdebugger.impl.XDebuggerManagerImpl
import dev.nx.console.telemetry.TelemetryEvent
import dev.nx.console.telemetry.TelemetryService
import dev.nx.console.utils.*

class NxCommandLineState(
    val environment: ExecutionEnvironment,
    val runConfiguration: NxCommandConfiguration
) : NodeBaseRunProfileState, NodeCommandLineOwner {
    override fun createExecutionResult(processHandler: ProcessHandler): ExecutionResult {
        ProcessTerminatedListener.attach(processHandler)
        val console = createConsole(processHandler, environment.project, true)
        console.attachToProcess(processHandler)
        foldCommandLine(console, processHandler)
        return DefaultExecutionResult(console, processHandler)
    }

    override fun startProcess(configurator: CommandLineDebugConfigurator?): ProcessHandler {
        val project: Project = environment.project
        val nxRunSettings = runConfiguration.nxRunSettings
        val nxProjects = nxRunSettings.nxProjects.split(",")
        val nxTargets = nxRunSettings.nxTargets.split(",")
        val nxTargetsConfiguration = nxRunSettings.nxTargetsConfiguration
        val args =
            if (nxProjects.size > 1 || nxTargets.size > 1) {
                val array =
                    arrayOf(
                        "run-many",
                        "--targets=${nxTargets.joinToString(separator = ",")}",
                        "--projects=${nxProjects.joinToString(separator = ",")}",
                    )
                if (nxTargetsConfiguration.isBlank().not()) {
                    array + "-c $nxTargetsConfiguration"
                } else {
                    array
                }
            } else
                arrayOf(
                    "run",
                    "${nxProjects.first()}:${nxTargets.first()}${if(nxTargetsConfiguration.isBlank().not()) ":$nxTargetsConfiguration" else ""}"
                )

        if (configurator != null) {
            try {
                val hideNotificationPropertyKey =
                    "dev.nx.console.hide_debug_source_map_notification"
                val lastNotificationTimeKey =
                    "dev.nx.console.last_debug_source_map_notification_time"

                val shouldHideNotification =
                    PropertiesComponent.getInstance(project).getBoolean(hideNotificationPropertyKey)

                // we don't want to spam users with notification but only show it in the correct
                // context
                val debugToolwindowIsVisible =
                    ToolWindowManager.getInstance(project)
                        .getToolWindow(XDebuggerManagerImpl.getNotificationGroup().toolWindowId)
                        ?.isVisible
                        ?: false

                val currentTime = System.currentTimeMillis()
                val lastNotificationTime =
                    PropertiesComponent.getInstance(project).getLong(lastNotificationTimeKey, 0)
                val tenMinutesPassed = (currentTime - lastNotificationTime) > 600000

                if (!shouldHideNotification && debugToolwindowIsVisible && tenMinutesPassed) {
                    val notification =
                        XDebuggerManagerImpl.getNotificationGroup()
                            .createNotification(
                                "For debugging to work with Nx Console, pl" +
                                    "ease ensure source maps are generated by the underlying tooling.",
                                MessageType.INFO
                            )
                    notification.addActions(
                        setOf(
                            NotificationAction.createSimpleExpiring("OK") { notification.expire() },
                            NotificationAction.createSimpleExpiring("Don't show again") {
                                notification.expire()
                                PropertiesComponent.getInstance(project)
                                    .setValue(hideNotificationPropertyKey, true)
                            }
                        )
                    )
                    notification.notify(project)
                    PropertiesComponent.getInstance(project)
                        .setValue(lastNotificationTimeKey, currentTime.toString())
                }
            } catch (e: Throwable) {
                // this is a completely un-critical operation, so we don't care if something goes
                // wrong during it
                thisLogger().debug("Failed to show source map notification", e)
            }

            TelemetryService.getInstance(project)
                .featureUsed(TelemetryEvent.TASKS_RUN, mapOf("debug" to true))
        } else {
            TelemetryService.getInstance(project)
                .featureUsed(TelemetryEvent.TASKS_RUN, mapOf("debug" to false))
        }

        val targetRun =
            NodeTargetRun(
                    project.nodeInterpreter,
                    project,
                    configurator,
                    NodeTargetRunOptions.of(true, runConfiguration)
                )
                .apply {
                    envData = nxRunSettings.environmentVariables
                    enableWrappingWithYarnNode = false
                }

        NodeCommandLineUtil.prependNodeDirToPATH(
            nxRunSettings.environmentVariables.envs,
            project.nodeInterpreter
        )

        targetRun.commandLineBuilder.apply {
            exePath = TargetValue.fixed(NxExecutable.getExecutablePath(project.nxBasePath, project))

            addParameters(
                listOf(
                    *args,
                    *(ParametersListUtil.parseToArray(nxRunSettings.arguments)),
                )
            )

            setWorkingDirectory(
                WslPath.parseWindowsUncPath(project.nxBasePath)?.linuxPath ?: project.nxBasePath
            )
        }

        return targetRun.startProcess()
    }
}
