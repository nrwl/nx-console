import { readFileSync } from 'fs';
import { gzipSync } from 'zlib';
import { join } from 'path';

export interface Chunk {
  name: string;
  file: string;
  size: string;
  type: string;
}

interface FileSize {
  gzipped: number;
  parsed: number;
}

interface FileSizeGetter {
  read: (path: string, cwd?: string) => FileSize;
}

class FileSystemFileSizeGetter implements FileSizeGetter {
  read(asset: string, cwd?: string) {
    const filePath = cwd ? join(cwd, '/', asset) : asset;
    const file = readFileSync(filePath);
    return {
      parsed: file.length,
      gzipped: gzipSync(file).length
    };
  }
}

export function parseStats(
  stats: any,
  cwd: string,
  fileSizeGetter: FileSizeGetter = new FileSystemFileSizeGetter()
) {
  const outputPath = stats.outputPath;
  // grouped by index as id since webpack ids are sequential numbers
  const modulesByChunkId: ModuleData[][] = [];
  const summary = {
    assets: createSizeData(),
    modules: createSizeData(),
    dependencies: createSizeData()
  };
  const assets: any[] = [];
  const chunks: ChunkData[] = [];

  stats.assets.forEach((asset: any) => {
    // Ignore the stats.json file generated by webpack.
    if (asset.name === 'stats.json') {
      return;
    }
    // Ignore sourcemaps.
    if (asset.name.endsWith('.map')) {
      return;
    }
    const sizes = fileSizeGetter.read(asset.name, cwd);
    summary.assets.parsed += sizes.parsed;
    summary.assets.gzipped += sizes.gzipped;
    assets.push({
      name: asset.name,
      chunkNames: asset.chunkNames,
      sizes: sizes
    });
  });

  stats.chunks.forEach((chunk: any) => {
    const chunkData = getChunkData(chunk);
    const chunkSizes = fileSizeGetter.read(chunkData.file, outputPath);
    const modules: ModuleData[] = [];

    chunkData.sizes.parsed = chunkSizes.parsed;
    chunkData.sizes.gzipped = chunkSizes.gzipped;
    chunks.push(chunkData);

    walkModules(chunk.modules, module => {
      if (module.path.startsWith('multi')) return;
      if (isBundle(module)) return;
      const moduleSizes = fileSizeGetter.read(module.path);

      module.sizes.parsed = moduleSizes.parsed;
      module.sizes.gzipped = moduleSizes.gzipped;

      summary.modules.parsed += module.sizes.parsed;
      summary.modules.gzipped += module.sizes.gzipped;

      if (module.isDep) {
        summary.dependencies.parsed += module.sizes.parsed;
        summary.dependencies.gzipped += module.sizes.gzipped;
      }

      modules.push(module);
    });

    modulesByChunkId[chunkData.id] = modules;
  });

  return {
    assets,
    chunks,
    errors: stats.errors,
    warnings: stats.warnings,
    modulesByChunkId,
    summary
  };
}

export function calculateStatsFromChunks(cs: Chunk[]) {
  const assets: any[] = [];
  const summary = {
    assets: createSizeData(),
    modules: createSizeData(),
    dependencies: createSizeData()
  };
  const chunks: ChunkData[] = [];

  cs.forEach((c, idx) => {
    const chunkData = {
      id: idx,
      file: c.file,
      name: c.name,
      sizes: createSizeData()
    };
    const size = parseSizeFromBuildOutput(c.size);

    chunkData.sizes.parsed = size;
    summary.assets.parsed += size;
    summary.modules.parsed += size;

    chunks.push(chunkData);
    assets.push({
      name: c.file,
      sizes: chunkData.sizes
    });
  });

  return {
    assets,
    chunks,
    errors: [],
    warnings: [],
    modulesByChunkId: [],
    summary
  };
}

/* ------------------------------------------------------------------------------------------------------------------ */

interface ChunkData {
  id: number;
  name: string;
  file: string;
  sizes: SizeData;
}

interface SizeData {
  gzipped: number;
  parsed: number;
}

interface Module {
  id: number;
  identifier: string;
  name: string;
  size: number;
  chunks: any[];
}

interface ModuleData {
  id: number;
  identifier: string;
  name: string;
  size: number;
  path: string;
  isDep: boolean;
  sizes: SizeData;
}

function createSizeData(): SizeData {
  return { gzipped: 0, parsed: 0 };
}

function walkModules(
  modules: Module[],
  visitor: (module: ModuleData) => void,
  seen: Set<string> = new Set<string>()
) {
  if (!modules) return;

  modules.forEach(m => {
    const path = getModulePath(m);
    const isDep = path.indexOf('node_modules') !== -1;
    const sizes = createSizeData();
    const mm: ModuleData = {
      id: m.id,
      name: m.name,
      identifier: m.identifier,
      size: m.size,
      path,
      isDep,
      sizes
    };

    if (isDep) {
    }

    if (!shouldInclude(mm)) return;
    if (seen.has(mm.path)) return;

    seen.add(mm.path);

    visitor(mm);
  });
}

function getModulePath(m: Module) {
  return m.identifier.replace(/.*!/, '').replace(/\\/g, '/');
}

function isBundle(m: ModuleData) {
  return /^.* [a-zA-Z0-9]+$/.test(m.path);
}

function shouldInclude(m: ModuleData) {
  return (
    m.identifier.indexOf('(webpack)') === -1 &&
    m.path.indexOf('$$_lazy_route_resource') === -1
  );
}

function getChunkData(chunk: any): ChunkData {
  return {
    id: chunk.id,
    name: chunk.names[0],
    file: chunk.files[0],
    sizes: createSizeData()
  };
}

function parseSizeFromBuildOutput(s: string) {
  const matched = s.toLowerCase().match(/([\d.]+)\s*(kb|b|mb)/);
  if (matched) {
    const x = Number(matched[1]);
    switch (matched[2]) {
      case 'b':
        return x;
      case 'kb':
        return x * 1000;
      case 'mb':
        return x * 1000 * 1000;
      // Realistically assets should not be this big
      case 'gb':
        return x * 1000 * 1000 * 1000;
      default:
        return 0;
    }
  } else {
    return 0;
  }
}
