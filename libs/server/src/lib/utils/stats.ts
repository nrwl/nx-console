import { readFileSync } from 'fs';
import { gzipSync } from 'zlib';
import { join } from 'path';

export interface Chunk {
  name: string;
  file: string;
  size: string;
  type: string;
}

interface FileSize {
  gzipped: number;
  parsed: number;
}

interface FileSizeGetter {
  read: (path: string, cwd?: string) => FileSize;
}

class FileSystemFileSizeGetter implements FileSizeGetter {
  read(asset: string, cwd?: string) {
    const filePath = cwd ? join(cwd, '/', asset) : asset;
    const file = readFileSync(filePath);
    return {
      parsed: file.length,
      gzipped: gzipSync(file).length
    };
  }
}

export function parseStats(
  stats: any,
  cwd: string,
  fileSizeGetter: FileSizeGetter = new FileSystemFileSizeGetter()
) {
  const outputPath = stats.outputPath;
  // grouped by index as id since webpack ids are sequential numbers
  const modulesByChunkId: { [key: string]: ModuleData[] } = {};
  const summary = {
    assets: createSizeData(),
    modules: createSizeData(),
    dependencies: createSizeData()
  };
  const assets: any[] = [];
  const chunks: ChunkData[] = [];

  stats.assets.forEach((asset: any) => {
    // Ignore the stats.json file generated by webpack.
    if (asset.name === 'stats.json') {
      return;
    }
    // Ignore sourcemaps.
    if (asset.name.endsWith('.map')) {
      return;
    }
    const sizes = fileSizeGetter.read(asset.name, outputPath);
    summary.assets.parsed += sizes.parsed;
    summary.assets.gzipped += sizes.gzipped;
    assets.push({
      name: asset.name,
      chunkNames: asset.chunkNames,
      sizes: sizes
    });
  });
  const pathPrefixRegexp = new RegExp(`^(\./|${cwd}/)`);

  stats.chunks.forEach((chunk: any) => {
    const chunkData = getChunkData(chunk);
    const chunkSizes = fileSizeGetter.read(chunkData.file, outputPath);
    const modules: ModuleData[] = [];

    chunkData.sizes.parsed = chunkSizes.parsed;
    chunkData.sizes.gzipped = chunkSizes.gzipped;
    chunks.push(chunkData);

    chunk.modules = flattenMultiModules(chunk.modules);
    chunk.modules = chunk.modules.filter(
      (m: Module) => !m.name.startsWith('multi')
    );

    walkModules(chunk.modules, module => {
      try {
        const moduleSizes = fileSizeGetter.read(module.path);

        module.sizes.parsed = moduleSizes.parsed;
        module.sizes.gzipped = moduleSizes.gzipped;

        summary.modules.parsed += module.sizes.parsed;
        summary.modules.gzipped += module.sizes.gzipped;

        if (module.isDep) {
          summary.dependencies.parsed += module.sizes.parsed;
          summary.dependencies.gzipped += module.sizes.gzipped;
        }

        // Strip out cwd from module name and path.
        module.path = module.name = module.path
          .split(pathPrefixRegexp)
          .slice(2)
          .join('');

        modules.push(module);
      } catch (err) {
        if (err.code === 'ENOENT') {
          // File may not exist when read, so we ca ignore it.
        } else {
          throw err;
        }
      }
    });

    modulesByChunkId[chunkData.id] = modules;
  });

  return {
    assets,
    chunks,
    errors: stats.errors,
    warnings: stats.warnings,
    modulesByChunkId,
    summary
  };
}

export function calculateStatsFromChunks(cs: Chunk[]) {
  const assets: any[] = [];
  const summary = {
    assets: createSizeData(),
    modules: createSizeData(),
    dependencies: createSizeData()
  };
  const chunks: ChunkData[] = [];

  cs.forEach((c, idx) => {
    const chunkData = {
      id: String(idx),
      file: c.file,
      name: c.name,
      sizes: createSizeData()
    };
    const size = parseSizeFromBuildOutput(c.size);

    chunkData.sizes.parsed = size;
    summary.assets.parsed += size;
    summary.modules.parsed += size;

    chunks.push(chunkData);
    assets.push({
      name: c.file,
      sizes: chunkData.sizes
    });
  });

  return {
    assets,
    chunks,
    errors: [],
    warnings: [],
    modulesByChunkId: [],
    summary
  };
}

/* ------------------------------------------------------------------------------------------------------------------ */

interface ChunkData {
  id: string;
  name: string;
  file: string;
  sizes: SizeData;
}

interface SizeData {
  gzipped: number;
  parsed: number;
}

interface Module {
  identifier: string;
  name: string;
  size: number;
  chunks: any[];
  modules: Module[];
}

interface ModuleData {
  identifier: string;
  name: string;
  size: number;
  path: string;
  isDep: boolean;
  sizes: SizeData;
}

function createSizeData(): SizeData {
  return { gzipped: 0, parsed: 0 };
}

const BUNDLED_MODULE_REGEXP = /(.*)\s+\+\s+\d+\smodules$/;

function flattenMultiModules(modules: Module[]) {
  let flattened = [] as Module[];
  modules.forEach(module => {
    const matched = module.name.match(BUNDLED_MODULE_REGEXP);
    if (matched) {
      flattened = flattened.concat(module.modules);
      module.name = matched[1];
    }
    flattened.push(module);
  });
  return flattened;
}

function walkModules(
  modules: Module[],
  visitor: (module: ModuleData) => void,
  seen: Set<string> = new Set<string>()
) {
  if (!modules) return;

  modules.forEach(m => {
    const path = getModulePath(m);
    const isDep = path.indexOf('node_modules') !== -1;
    const sizes = createSizeData();
    const mm: ModuleData = {
      name: path,
      identifier: m.identifier,
      size: m.size,
      path,
      isDep,
      sizes
    };

    if (!shouldInclude(mm)) return;
    if (seen.has(mm.path)) return;

    seen.add(mm.path);

    visitor(mm);
  });
}

function getModulePath(m: Module) {
  return m.identifier.replace(/.*!/, '').replace(/\\/g, '/');
}

function shouldInclude(m: ModuleData) {
  return (
    m.identifier.indexOf('(webpack)') === -1 &&
    m.path.indexOf('$$_lazy_route_resource') === -1
  );
}

function getChunkData(chunk: any): ChunkData {
  return {
    id: String(chunk.id),
    name: chunk.names[0],
    file: chunk.files[0],
    sizes: createSizeData()
  };
}

function parseSizeFromBuildOutput(s: string) {
  const matched = s.toLowerCase().match(/([\d.]+)\s*(kb|b|mb)/);
  if (matched) {
    const x = Number(matched[1]);
    switch (matched[2]) {
      case 'b':
        return x;
      case 'kb':
        return x * 1000;
      case 'mb':
        return x * 1000 * 1000;
      // Realistically assets should not be this big
      case 'gb':
        return x * 1000 * 1000 * 1000;
      default:
        return 0;
    }
  } else {
    return 0;
  }
}
